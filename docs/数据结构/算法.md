#### [76. 最小覆盖子串](https://leetcode-cn.com/problems/minimum-window-substring/)

```c++
class Solution {
public:
    string minWindow(string s, string t) {
        unordered_map<char,int> need,window;
        for (char c:t)need[c]++;
        int left=0,right=0;
        int valid=0;
        int start=0,len=INT_MAX;
        while(right<s.size()){
            char c=s[right];
            right++;
            if (need.count(c)){
                window[c]++;
                if (window[c]==need[c])
                    valid++;
            }

            while(valid==need.size()){
                if (right-left<len){
                    start=left;
                    len=right-left;
                }
                char d=s[left];
                left++;
                if (need.count(d)){
                    if(window[d]==need[d])
                        valid--;
                    window[d]--;
                }
            }
        }
        return len==INT_MAX?"":s.substr(start,len);
    }
};
```

```go
func minWindow(s string, t string) string {
    need:=make(map[byte]int)
    window:=make(map[byte]int)
    for c:=range(t){
        need[t[c]]++
    }
    left,right:=0,0
    vaild:=0
    start,lens:=0,int(^uint(0) >> 1)
    for right<len(s){
        c:=s[right]
        right++
        if need[c]>0{
            window[c]++;
            if window[c]==need[c]{
                vaild++
            }
        }
        for vaild==len(need){
            if right-left<lens{
                start=left
                lens=right-left
            }
            d:=s[left]
            left++
            if need[d]>0{
                if window[d]==need[d]{
                    vaild--
                }
                window[d]--
            }
        }
    }
    if lens==int(^uint(0) >> 1){
        return ""
    }else{
        // return fmt.Sprintf(strconv.Itoa(lens)+strconv.Itoa(start))
        return s[start:start+lens]
    }
}
```